'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Checkbox } from '@/components/ui/checkbox';
import { useRouter } from 'next/navigation';
import { Loader2, MapPin, CheckCircle, XCircle } from 'lucide-react';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { addMethanisationSite } from '@/services/dealerService';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'; // Make sure Select is imported
// Initial data
import type { NewMethanisationSiteData, GeoLocation, Comment, MethanisationSiteClient } from '@/types'; // Import types
const initialData: NewMethanisationSiteData = {
  id: '', // Assuming ID is generated by the backend
  name: '',
  entityType: 'methanisation-site', // Default type
  address: '',
  city: '',
  postalCode: '',
  country: '', // Changed default to empty string as it's required and needs input
  geoLocation: undefined,
  createdAt: '', // Changed to empty string as it's set by backend
 updatedAt: '', // Changed to empty string as it's set by backend
  capacity: '',
  operator: '',
  startDate: undefined,
 legalType: '',
  siretSiren: '',
  mainContact: '',
  siteClients: [], // Array field
  department: '',
  phone: '',
  email: '', // Ensure email is part of NewMethanisationSiteData if required
  website: '',
  urbanOrRuralArea: '',
 proximityToStepIsdnd: '',
 projectType: '', // Add projectType field
 valorizationType: '',
 icpeStatus: '',
  icpeRegime: '',
  mainIntrantsType: '',
  majorityAgriculturalCapital: false, // Boolean field
  legalStructure: '',
  authorizedVolume: '',
  installedElectricalPower: '',
  installedThermalPower: '',
  maxBiomethaneFlow: '',
  estimatedAnnualProduction: '',
  commissioningYear: 0, // Number field
  boilerMotorType: '',
  operatingHours: 0, // Number field
  icpeFileNumber: '',
 prefecturalDecree: '',
  prospectionStatus: 'none',
 comments: [], // Array field
  publicConsultationLink: '',
  publicSubsidies: '', // Add publicSubsidies field
  drealInspection: '',
  operationalStatus: '',
  extensionProjects: '',
  incidentHistory: '',
  publicOpinion: '',
 technologies: [], // Array field
  relatedDealerIds: [], // Array field
};

// Removed MethanisationSiteFormProps interface as onSubmit is now handled in the parent page
// interface MethanisationSiteFormProps {
//   onSubmit: (data: NewMethanisationSiteData) => Promise<void>;
// }

export default function MethanisationSiteForm({ onSubmit }: { onSubmit: (data: NewMethanisationSiteData) => Promise<void> }) {
  const [data, setData] = useState(initialData);
  const [isLoading, setIsLoading] = useState(false);
  const [newCommentText, setNewCommentText] = useState(''); // State for the new comment input
  const [editingCommentIndex, setEditingCommentIndex] = useState<number | null>(null); // State for editing a comment
  const [editedCommentText, setEditedCommentText] = useState(''); // State for the edited comment text
  const [addrValid, setAddrValid] = useState<boolean|null>(null);
  const [isGeocoding, setIsGeocoding] = useState(false); // State for geocoding loading
  const [showNewClientForm, setShowNewClientForm] = useState(false); // State to control visibility of new client form
  const [error, setError] = useState<string | null>(null); // State to manage form errors
  const [newClientData, setNewClientData] = useState<MethanisationSiteClient>({ name: '', contactEmail: '', contactPhone: '' }); // State for new client data

  const handleChange = (e: React.ChangeEvent<HTMLInputElement|HTMLTextAreaElement|HTMLSelectElement>) => {
    const { name, value } = e.target;
    if (name === 'technologies') {
      // Split the comma-separated string into an array of strings
      setData(prev => ({ ...prev, [name]: value.split(',').map(tech => tech.trim()).filter(tech => tech !== '') }));
    } else {
      setData(prev => ({ ...prev, [name]: value }));
    }
    if (['address','city','postalCode','country'].includes(name)) {
      setAddrValid(null);
      setData(prev => ({ ...prev, geoLocation: undefined }));
    }
  };

  const geocode = async () => {
    if (!data.address || !data.city || !data.postalCode || !data.country) {
      setError('Veuillez remplir l\'adresse, la ville, le code postal et le pays avant de géocoder.');
      return;
    }
    setIsGeocoding(true);
    setError(null); // Clear previous errors
    setAddrValid(null); // Reset address validation status

    try {
      // call real service
      const fullAddress = `${data.address}, ${data.postalCode} ${data.city}, ${data.country}`;
      console.log('Attempting to geocode address:', fullAddress);
      // TODO: Replace this with a call to a real geocoding service API.
      // Example: const result = await geocodingService.geocodeAddress(fullAddress); // Assuming geocodingService exists
      // If successful:
      // setData(prev => ({ ...prev, geoLocation: result.geoLocation }));
      // setAddrValid(true);
      // If failed:
      // setAddrValid(false);
      // setError('Erreur géocodage');

       // TEMPORARY: Mock geocoding success
      await new Promise(r => setTimeout(r, 1500)); // Simulate API call delay
      const mockGeoLocation = { lat: 48.1173 + Math.random() * 0.1, lng: -1.6778 + Math.random() * 0.1 }; // Mock coordinates near Rennes
      setData(prev => ({ ...prev, geoLocation: mockGeoLocation }));
      setAddrValid(true);
      console.log('Geocoding successful (mock):', mockGeoLocation);

    } catch (error) {
      console.error("Geocoding error:", error);
      setAddrValid(false);
      setError('Erreur lors du géocodage. Veuillez vérifier l\'adresse.');
    } finally {
      setIsGeocoding(false);
    }
  };

  // Handle adding a new comment
  const handleAddComment = () => {
    if (newCommentText.trim() === '') {
      return; // Don't add empty comments
    }
    const newComment: any = { // TODO: Use Comment type
      userName: 'Current User', // Replace with actual user name or handle in backend
      date: new Date().toISOString(),
      text: newCommentText.trim(),
      // Add other comment fields if needed (imageUrl, fileUrl, etc.)
    };
    setData(prevData => ({
      ...prevData,
      comments: [...prevData.comments, newComment],
    }));
    setNewCommentText(''); // Clear the input field
  };

  // Handle editing a comment
  const handleEditComment = (index: number) => {
    setEditingCommentIndex(index);
    setEditedCommentText(data.comments[index].text);
  };

  // Handle saving the edited comment
  const handleSaveComment = (index: number) => {
    if (editedCommentText.trim() === '') {
       // Optionally handle empty edit attempts
       return;
    }
    const updatedComments = data.comments.map((comment: any, i: number) => { // TODO: Use Comment type
       if (i === index) {
          return { ...comment, text: editedCommentText.trim(), date: new Date().toISOString() }; // Update date on edit?
       }
       return comment;
    });
    setData(prevData => ({
       ...prevData,
       comments: updatedComments,
    }));
    setEditingCommentIndex(null); // Exit editing mode
    setEditedCommentText(''); // Clear edited text state
  };

  // Handle canceling edit
  const handleCancelEdit = () => {
    setEditingCommentIndex(null);
    setEditedCommentText('');
  };

  // Handle deleting a comment
  const handleDeleteComment = (index: number) => {
    const updatedComments = data.comments.filter((_: any, i: number) => i !== index); // TODO: Use Comment type
    setData(prevData => ({ ...prevData, comments: updatedComments }));
  };

  // Handle input change for new client form
  const handleNewClientInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setNewClientData(prev => ({ ...prev, [name]: value }));
  };

  // Handle saving a new client
  const handleSaveClient = () => {
    if (newClientData.name.trim() === '') {
      return; // Don't add client without a name
    }
    setData(prevData => ({ ...prevData, siteClients: [...prevData.siteClients, newClientData] }));
    setNewClientData({ name: '', contactEmail: '', contactPhone: '' }); // Reset new client form
    setShowNewClientForm(false); // Hide the form
  };

  // Validation function
  const validateForm = (): boolean => {
    setError(null); // Clear previous errors
    if (!data.name.trim()) { setError('Le nom du site est obligatoire.'); return false; }
    if (!data.siretSiren.trim()) { setError('Le SIRET/SIREN est obligatoire.'); return false; }
    if (!data.address.trim() || !data.city.trim() || !data.postalCode.trim() || !data.country.trim()) {
      setError('L\'adresse complète est obligatoire.');
      return false;
    }
    // If geocoding was attempted and failed, or was attempted and returned no location
    if (addrValid === false || (addrValid === true && !data.geoLocation)) {
         setError('La géolocalisation de l\'adresse a échoué ou n\'a pas été validée.');
         return false;
    }

    // Add other required field checks here as needed

    return true; // Form is valid
  };

  return (
    <div className="space-y-6"> {/* Use a div to wrap the Tabs and button */}
      <Tabs defaultValue="identification" className="w-full">
      <TabsList className="grid w-full grid-cols-4">
 <TabsTrigger value="identification">Identification</TabsTrigger>
 <TabsTrigger value="localisation">Localisation</TabsTrigger>
 <TabsTrigger value="details">Détails</TabsTrigger>
 <TabsTrigger value="prospection">Prospection</TabsTrigger>
      </TabsList>

 <TabsContent value="identification">
 <div className="space-y-4">
 <h2 className="text-xl font-semibold">Identification</h2>
 <div>
 <Label htmlFor="name">Nom du site *</Label>
 <Input name="name" value={data.name} onChange={handleChange} size="lg" />
 </div>
 <div>
 <Label htmlFor="siretSiren">SIRET / SIREN *</Label>
 <Input name="siretSiren" value={data.siretSiren} onChange={handleChange} size="lg" />
 </div>
 </div>
 </TabsContent>

 <TabsContent value="localisation">
 <div className="space-y-4">
 <h2 className="text-xl font-semibold">Localisation</h2>
 <div><Label>Adresse *</Label><Input name="address" value={data.address} onChange={handleChange} size="lg" /></div>
 <div className="grid grid-cols-3 gap-4">
 <div><Label>Code postal *</Label><Input name="postalCode" value={data.postalCode} onChange={handleChange} size="lg" /></div>
 <div><Label>Ville *</Label><Input name="city" value={data.city} onChange={handleChange} size="lg" /></div>
 <div><Label>Pays *</Label><Input name="country" value={data.country} onChange={handleChange} size="lg" /></div>
 </div>
 <div className="flex items-center gap-2">
 <Button onClick={geocode} disabled={isGeocoding} size="sm">
              {isGeocoding ? <Loader2 className="animate-spin mr-2"/> : <MapPin className="mr-2"/>} Géocoder
 </Button>
            {addrValid===true && <CheckCircle className="text-green-500"/>}
            {addrValid===false && <XCircle className="text-red-500"/>}
 </div>
          {data.geoLocation && <p>Lat {data.geoLocation.lat.toFixed(4)}, Lng {data.geoLocation.lng.toFixed(4)}</p>}
 </div>
 </TabsContent>

 <TabsContent value="details">
 <div className="space-y-4">
 <h2 className="text-xl font-semibold">Détails Opérationnels</h2>
 <div className="grid grid-cols-2 gap-4">
 <div><Label>Opérateur</Label><Input name="operator" value={data.operator} onChange={handleChange} size="lg"/></div>
 <div><Label>Capacité</Label><Input name="capacity" value={data.capacity} onChange={handleChange} size="lg"/></div>
 </div>
 <div><Label>Année mise en service</Label><Input type="number" name="commissioningYear" value={data.commissioningYear} onChange={handleChange} size="lg"/></div>
 <div><Label>Énergie primaire (MWh)</Label><Input name="energyPrimary" value={data.energyPrimary} onChange={handleChange} size="lg"/></div>
 <div><Label>Valorisation</Label><Input name="valorizationType" value={data.valorizationType} onChange={handleChange} size="lg"/></div>
 <div className="grid grid-cols-3 gap-4">
 <div><Label>Puiss. éléctrique (kWe)</Label><Input name="installedElectricalPower" value={data.installedElectricalPower} onChange={handleChange} size="lg"/></div>
 <div><Label>Puiss. thermique (kWth)</Label><Input name="installedThermalPower" value={data.installedThermalPower} onChange={handleChange} size="lg"/></div>
 <div><Label>Débit biométhane (m³/h)</Label><Input name="maxBiomethaneFlow" value={data.maxBiomethaneFlow} onChange={handleChange} size="lg"/></div>
 </div>
 </div>
 {/* Add technologies field */}
          <div>
            <Label htmlFor="technologies">Technologies (séparées par des virgules)</Label>
            <Input name="technologies" value={data.technologies.join(', ')} onChange={handleChange} size="lg" />
          </div>
          {/* Add Clients du Site Section */}
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Clients du Site</h3>
            <Button size="sm" onClick={() => setShowNewClientForm(true)}>{showNewClientForm ? 'Annuler' : 'Ajouter un client'}</Button>

            {showNewClientForm && (
              <div className="border rounded-md p-4 space-y-3">
                <h4 className="text-md font-medium">Nouveau Client</h4>
                <div>
                  <Label htmlFor="newClientName">Nom du Client *</Label>
                  <Input id="newClientName" name="name" value={newClientData.name} onChange={handleNewClientInputChange} size="sm" />
                </div>
                <div>
                  <Label htmlFor="newClientEmail">Email</Label>
                  <Input id="newClientEmail" name="contactEmail" value={newClientData.contactEmail} onChange={handleNewClientInputChange} type="email" size="sm" />
                </div>
                <div>
                  <Label htmlFor="newClientPhone">Téléphone</Label>
                  <Input id="newClientPhone" name="contactPhone" value={newClientData.contactPhone} onChange={handleNewClientInputChange} size="sm" />
                </div>
                <div className="flex justify-end gap-2">
                  <Button variant="outline" size="sm" onClick={() => setShowNewClientForm(false)}>Annuler</Button>
                  <Button size="sm" onClick={handleSaveClient}>Enregistrer Client</Button>
                </div>
              </div>
            )}

            <div className="border rounded-md p-3">
              {data.siteClients && data.siteClients.length > 0 ? (
                data.siteClients.map((client, index) => (
                  <div key={index} className="text-sm border-b last:border-b-0 pb-2">
                    <p className="font-medium">{client.name}</p>
                    {client.contactEmail && <p className="text-muted-foreground">Email: {client.contactEmail}</p>}
                    {client.contactPhone && <p className="text-muted-foreground">Téléphone: {client.contactPhone}</p>}
                    {/* TODO: Add Edit/Delete buttons for clients */}
                  </div>
                ))
              ) : (
                <p className="text-muted-foreground text-sm">Aucun client ajouté pour l'instant.</p>
              )}
            </div>
          </div>
          {/* Add Concessionnaires Liés Section */}
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Concessionnaires Liés</h3>
            {/* TODO: Add a MultiSelect component here to select related dealers */}
          </div>
 </TabsContent>

 <TabsContent value="prospection">
 <div className="space-y-4">
 <h2 className="text-xl font-semibold">Suivi de Prospection</h2>
          <div>
            <Label>Statut prospection</Label>
            <Select onValueChange={(v)=>setData(d=>({ ...d, prospectionStatus:v}))} value={data.prospectionStatus}>
              <SelectTrigger><SelectValue placeholder="Select statut"/></SelectTrigger>
              <SelectContent>
                <SelectItem value="none">Aucun</SelectItem>
                <SelectItem value="cold">Froid</SelectItem>
                <SelectItem value="warm">Tiède</SelectItem>
                <SelectItem value="hot">Chaud</SelectItem>
                <SelectItem value="converted">Converti</SelectItem>
                <SelectItem value="lost">Perdu</SelectItem>
              </SelectContent>
            </Select>
          </div>
          {/* Comments Section */}
          <div className="space-y-3">
            <h3 className="text-lg font-semibold">Commentaires</h3>
            {/* Display Existing Comments */}
            <div className="border rounded-md p-3 space-y-3 max-h-60 overflow-y-auto">
              {data.comments && data.comments.length > 0 ? (
                data.comments.map((comment: Comment, index: number) => (
                  <div key={index} className="text-sm border-b last:border-b-0 pb-2 space-y-1">
                    <p className="font-medium flex justify-between items-center">
                       <span>{comment.userName} - {new Date(comment.date).toLocaleDateString()}</span>
                       <div className="flex gap-2">
                         {editingCommentIndex !== index && (
                           <Button variant="ghost" size="sm" onClick={() => handleEditComment(index)}>Modifier</Button>
                         )}
                         <Button variant="ghost" size="sm" onClick={() => handleDeleteComment(index)} className="text-red-500 hover:text-red-600">Supprimer</Button>
                       </div>
                    </p>
                    {editingCommentIndex === index ? (
                      <div className="flex flex-col gap-2">
                        <Textarea value={editedCommentText} onChange={(e) => setEditedCommentText(e.target.value)} />
                        <div className="flex justify-end gap-2">
                           <Button variant="outline" size="sm" onClick={handleCancelEdit}>Annuler</Button>
                           <Button size="sm" onClick={() => handleSaveComment(index)}>Enregistrer</Button>
                        </div>
                      </div>
                    ) : (
                      <p className="text-muted-foreground">{comment.text}</p>
                    )}
                  </div>
                ))
              ) : (
                // Added this placeholder message
                <p className="text-muted-foreground text-sm">Aucun commentaire pour l'instant.</p>
              )}
            </div>
            {/* Add New Comment Form */}
            <div className="flex flex-col gap-2">
              <Textarea placeholder="Ajouter un commentaire..." value={newCommentText} onChange={(e) => setNewCommentText(e.target.value)} />
              <Button type="button" onClick={handleAddComment} size="sm" className="self-end">Ajouter un commentaire</Button>
            </div>
          </div>
        </div>
 </form>
      </TabsContent>
    </Tabs>

      {/* Global Submit Button */}
      <Button
        className="w-full"
        onClick={async () => {
          if (validateForm()) {
            await onSubmit(data);
          }
        }}
        disabled={isLoading || isGeocoding} // Disable button when loading or geocoding
      >
        {isLoading ? <Loader2 className="animate-spin mr-2" /> : null}
        Enregistrer le Site
      </Button>

      {error && (
        <Alert variant="destructive">
          <AlertTitle>Erreur</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
  );
};
  console.error("Form Error:", message);
};
